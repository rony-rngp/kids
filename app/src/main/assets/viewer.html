<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Remote Kids Monitor Control</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --background-color: #121212;
            --surface-color: #1e1e1e;
            --on-surface-color: #ffffff;
            --error-color: #cf6679;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            background-color: var(--background-color);
            color: var(--on-surface-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 500px;
            background-color: var(--surface-color);
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 1.5em;
        }

        main {
            padding: 20px;
        }

        .section {
            margin-bottom: 24px;
        }

        h2 {
            font-size: 1.2em;
            margin-bottom: 12px;
            color: var(--primary-color);
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 8px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 16px;
        }

        .input-group p {
            margin: 0;
            font-size: 0.9em;
            color: var(--secondary-color);
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: var(--on-surface-color);
            border-radius: 8px;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 12px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            background-color: var(--primary-color);
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button.disconnect {
            background-color: var(--error-color);
        }
        
        button.disconnect:hover {
            background-color: #b04f5d;
        }

        #status {
            margin-top: 10px;
            padding: 12px;
            border: 1px solid #3a3a3a;
            background-color: #2a2a2a;
            border-radius: 8px;
            min-height: 100px;
            white-space: pre-wrap;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            overflow-y: auto;
        }

        #videoFeed {
            width: 100%;
            height: auto;
            border: 1px solid #3a3a3a;
            margin-top: 16px;
            display: none; /* Hidden by default */
            border-radius: 8px;
        }

        #serviceStatus {
            padding: 12px;
            background-color: #2a2a2a;
            border-radius: 8px;
            font-weight: bold;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>Remote Kids Monitor Control</header>
        <main>
            <section class="section">
                <h2><i class="fas fa-network-wired"></i> Connection</h2>
                <div class="input-group">
                    <p>Enter the IP address of the monitored Android device (e.g., 192.168.1.100).</p>
                    <input type="text" id="ipAddress" placeholder="Enter Phone IP Address">
                    <div class="button-group">
                        <button onclick="connectWebSocket()"><i class="fas fa-plug"></i> Connect</button>
                        <button onclick="disconnectWebSocket()" class="disconnect"><i class="fas fa-unplug"></i> Disconnect</button>
                    </div>
                </div>
            </section>

            <section class="section">
                <h2><i class="fas fa-info-circle"></i> Status</h2>
                <div id="status">Not Connected</div>
            </section>
            
            <section class="section">
                <h2><i class="fas fa-cogs"></i> Running Services</h2>
                <div id="serviceStatus">Camera: OFF, Audio: OFF</div>
            </section>

            <section class="section" id="controls" style="display: none;">
                <h2><i class="fas fa-video"></i> Live Video Feed</h2>
                <img id="videoFeed" src="" alt="Live Video Stream">

                <h2><i class="fas fa-gamepad"></i> Controls</h2>
                <div class="controls-grid">
                    <button id="startMonitoring" onclick="sendCommand('startMonitoring')"><i class="fas fa-play-circle"></i> Start Monitor</button>
                    <button id="stopMonitoring" onclick="sendCommand('stopMonitoring')" style="display: none;"><i class="fas fa-stop-circle"></i> Stop Monitor</button>
                    <button onclick="sendCommand('switchCamera', { facing: 'front' })"><i class="fas fa-sync-alt"></i> Front Camera</button>
                    <button onclick="sendCommand('switchCamera', { facing: 'back' })"><i class="fas fa-sync-alt"></i> Back Camera</button>
                    <button id="startAudio" onclick="sendCommand('audioOn')"><i class="fas fa-microphone"></i> Start Audio</button>
                    <button id="stopAudio" onclick="sendCommand('audioOff')" style="display: none;"><i class="fas fa-microphone-slash"></i> Stop Audio</button>
                </div>
            </section>
        </main>
    </div>

    <script>
        let ws;
        const statusDiv = document.getElementById('status');
        const ipAddressInput = document.getElementById('ipAddress');
        const controlsDiv = document.getElementById('controls');
        const videoFeedImg = document.getElementById('videoFeed');
        const serviceStatusDiv = document.getElementById('serviceStatus');
        const startMonitoringBtn = document.getElementById('startMonitoring');
        const stopMonitoringBtn = document.getElementById('stopMonitoring');
        const startAudioBtn = document.getElementById('startAudio');
        const stopAudioBtn = document.getElementById('stopAudio');

        let audioContext;
        let nextAudioTime = 0;
        let isCameraOn = false;
        let isAudioOn = false;
        let heartbeatInterval;
        const statusLogs = []; // Array to store recent status messages

        function updateStatus(message, append = true) {
            const now = new Date();
            const formattedMessage = `<strong>[${now.toLocaleTimeString()}]</strong> ${message}`;
            statusLogs.push(formattedMessage); // Add new message to the end

            // Keep only the last 5 messages
            if (statusLogs.length > 5) {
                statusLogs.shift(); // Remove the oldest message from the beginning
            }
            
            // Display messages in reverse order (newest first)
            statusDiv.innerHTML = statusLogs.slice().reverse().join('<br>');
        }

        function updateServiceStatus() {
            serviceStatusDiv.textContent = `Camera: ${isCameraOn ? 'ON' : 'OFF'}, Audio: ${isAudioOn ? 'ON' : 'OFF'}`;
            startMonitoringBtn.style.display = isCameraOn ? 'none' : 'block';
            stopMonitoringBtn.style.display = isCameraOn ? 'block' : 'none';
            startAudioBtn.style.display = isAudioOn ? 'none' : 'block';
            stopAudioBtn.style.display = isAudioOn ? 'block' : 'none';
        }

        function connectWebSocket() {
            const ip = ipAddressInput.value;
            if (!ip) {
                updateStatus('Error: Please enter the phone\'s IP address.');
                return;
            }
            const wsUrl = `ws://${ip}:8082`;

            if (ws && ws.readyState === WebSocket.OPEN) {
                updateStatus('Already connected.');
                return;
            }

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                nextAudioTime = audioContext.currentTime;
            } catch (e) {
                console.error("Web Audio API is not supported in this browser.", e);
                updateStatus('Web Audio API not supported.');
                return;
            }

            updateStatus('Attempting to connect to WebSocket...');
            ws = new WebSocket(wsUrl);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                updateStatus('WebSocket Connected. Controls enabled.', false);
                controlsDiv.style.display = 'block';
                isCameraOn = false;
                isAudioOn = false;
                updateServiceStatus();
                heartbeatInterval = setInterval(() => {
                    sendCommand('ping');
                }, 5000);
                // APK will send IP automatically on connection
            };

            ws.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    const rawData = new Int16Array(event.data);
                    const floatData = new Float32Array(rawData.length);
                    for (let i = 0; i < rawData.length; i++) {
                        floatData[i] = rawData[i] / 32768.0;
                    }
                    
                    const audioBuffer = audioContext.createBuffer(1, floatData.length, 16000);
                    audioBuffer.copyToChannel(floatData, 0);
                    
                    playBuffer(audioBuffer);
                } else {
                    try {
                        const message = JSON.parse(event.data);
                        if (message.type === 'status') {
                            updateStatus(`APK Status: ${message.message}`);
                            if (message.message.includes('Monitoring started')) {
                                isCameraOn = true;
                            } else if (message.message.includes('Monitoring stopped')) {
                                isCameraOn = false;
                                isAudioOn = false; // Audio also stops when monitoring stops
                            } else if (message.message.includes('Audio monitoring started')) {
                                isAudioOn = true;
                            } else if (message.message.includes('Audio monitoring stopped')) {
                                isAudioOn = false;
                            } else if (message.message.includes('Camera switched to')) {
                                // Camera switch doesn't change overall monitoring state, just the camera used
                            }
                            updateServiceStatus();
                        } else if (message.isCameraOn !== undefined && message.isAudioOn !== undefined) {
                            isCameraOn = message.isCameraOn;
                            isAudioOn = message.isAudioOn;
                            updateServiceStatus();
                        } else if (message.type === 'error') {
                            updateStatus(`APK Error: ${message.message}`);
                        } else if (message.type === 'ipAddress') {
                            ipAddressInput.value = message.ip; // Auto-fill if not already set by user
                            updateStatus(`APK IP: ${message.ip}`);
                        }
                        else {
                            updateStatus(`Received: ${event.data}`);
                        }
                    } catch (e) {
                        updateStatus(`Received (non-JSON text): ${event.data}`);
                    }
                }
            };

            ws.onclose = () => {
                updateStatus('WebSocket Disconnected. Controls disabled.', false);
                controlsDiv.style.display = 'none';
                videoFeedImg.style.display = 'none';
                videoFeedImg.src = '';
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                }
                isCameraOn = false;
                isAudioOn = false;
                updateServiceStatus();
                clearInterval(heartbeatInterval);
            };

            ws.onerror = (error) => {
                updateStatus(`WebSocket Error: ${error.message || 'Unknown error'}`, false);
                console.error('WebSocket Error:', error);
            };
        }

        function playBuffer(buffer) {
            if (!audioContext || audioContext.state === 'closed') return;
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            
            const currentTime = audioContext.currentTime;
            if (currentTime < nextAudioTime) {
                source.start(nextAudioTime);
                nextAudioTime += buffer.duration;
            } else {
                source.start();
                nextAudioTime = currentTime + buffer.duration;
            }
        }

        function disconnectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            } else {
                updateStatus('Not connected.', false);
            }
            clearInterval(heartbeatInterval);
        }

        function sendCommand(commandType, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const command = {
                    type: commandType,
                    data: data
                };
                ws.send(JSON.stringify(command));
                updateStatus(`Sent command: ${commandType}`);

                if (commandType === 'startMonitoring') {
                    const ip = ipAddressInput.value;
                    if (ip) {
                        videoFeedImg.src = `http://${ip}:8081`;
                        videoFeedImg.style.display = 'block';
                    } else {
                        updateStatus('Cannot start video feed: IP address not set.');
                    }
                } else if (commandType === 'stopMonitoring') {
                    videoFeedImg.style.display = 'none';
                    videoFeedImg.src = '';
                } else if (commandType === 'audioOn') {
                    isAudioOn = true;
                } else if (commandType === 'audioOff') {
                    isAudioOn = false;
                }
                updateServiceStatus();

            } else {
                updateStatus('Not connected to WebSocket. Please connect first.');
            }
        }

        // Auto-fill IP from local storage or prompt
        window.onload = () => {
            const savedIp = localStorage.getItem('monitorIpAddress');
            if (savedIp) {
                ipAddressInput.value = savedIp;
            }

            ipAddressInput.addEventListener('change', () => {
                localStorage.setItem('monitorIpAddress', ipAddressInput.value);
            });
        };
    </script>
</body>
</html>